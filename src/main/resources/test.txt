public class Builder {
  public <T extends EntityPathBase> Builder where(Class<T> entityClass, FunctionInterface<BooleanExpression, T> whereFunction) {
    where = where.and(whereFunction.function(getEntity(entityClass))); return this;
  }
  public <T extends EntityPathBase> Builder orderBy(Class<T> entityClass, FunctionInterface<OrderSpecifier, T> whereFunction) {
    orderBy.add(whereFunction.function(getEntity(entityClass))); return this;
  }
  public Builder limit(long limit, long page) {
            this.limit = limit; this.page = page; return this;
  }
  public ResponseProjectListDto commit(Long userId){
    orderBy.add(projectEntity.createdAt.desc());
    List<ResponseProjectListDetailDto> projectList = selectProjects(userId, where, orderBy.toArray(OrderSpecifier[]::new));
    projectList = setTag(projectList);
    return new ResponseProjectListDto(projectList, totalCount(where), limit, page);
  }
}

List<ProjectListDto> selectProjectDsl(Long userId,List<Long> tagIds,String search,(생략)){
  return queryFactory
    .selectDistinct(Projections.constructor(ResponseProjectListDetailDto.class,
      projectEntity.id,
      projectEntity.title,
      projectEntity.titleImg,
      projectEntity.createdAt,
      projectEntity.expired,
      projectEntity.goal,

      fundingDslRepository.completeRate(projectEntity), // completeRate
      likeCount(projectEntity), // like count
      fundingDslRepository.fundingUserCount(projectEntity), // user_count
      isLike(projectEntity, userId), // is_like
      viewCount(projectEntity), // view_count
      projectViewEntity.createAt // select distinct 용 컬럼
      ))
    .from(projectEntity)
    .leftJoin(생략)
    .where(where)
    .orderBy(orderBy)
    .fetch();
}

List<ProjectListDto> selectProjectDsl(
    Long userId ,
    List<Long> tagIds ,
    String search ,
    OrderType order ,
    Boolean desc ,
    MyPageWhereType type ,
    Long pageCount ,
    (생략)
);

    private Long userId;
    private List<Long> tag;
    private String order;
    private String search;
    private Boolean desc;
    private Integer page = 0;
    private MyPageWhere myPageWhere;
    private Long pageCount = 10000L;

문제 2개 이상의 service에서 사용하기 위한 확장이 필요함!
1. 각 service에서 사용되는 모든 Type들을 받아서 내부에서 where, order by절을 완성 (domain별로 쿼리 구분)
2. 각 service에서 where, order by절을 완성해서 넘겨주면 select부분만 실행
유지 보수 : 모든 service에서 필요한 기능들을 ProjectDSLRepo.class에 담는 것 보다는 각각의 service에서 구현하는 것이 옭다
    단, 복잡한 로직이 필요한 부분만(총 funding금액, 목표 금액 계산) 해당 domain에서 구현해서 함수화 한다
확장성 : 추가 service가 생겨도 필요한 where, order by만 작성하면 완료!

1. 내부 builder class를 통해 다른 service에서 사용면을 편하게 함
2. interface, lambda를 활용해 정확히 where, order by에 필요한 QEntity를 제공, return type을 명시

다른 service들에서 호출할 방법을 어느 정도 결정해 두고 내부를 구현했습니다.

결과 : 확장성 증가 (다른 service에서 사용 가능해졌음), service별 필요한 where, order by를 직접 구현함으로 가독성/유지 보수 증가
추가 refactoring 필요 : 모든 기능에서 필요한 table을 모두 join하는 것은 성능에 문제가 많다. join부분도 필요한 table만 외부 주입 받을 필요가 있다
느낀점/배운점 : 제네릭을 활용한 기능 구현 방법을 익혔음 (함수별 제네릭 사용이 가능하다), 외부 service의 사용 방법을 먼저 정해놓고 기능 구현하는 과정이 의미있었다.

  // ProjectSelectRepo의 내부 builder class
  public <T extends EntityPathBase> Builder where(
    Class<T> entityClass,
    FunctionInterface<BooleanExpression, T> whereFunction
  ) {
    where = where.and(whereFunction.function(getEntity(entityClass)));
  }


짜피 내부 Builder class는 필요 없지 않을까?
처음과 끝만 보여준다
목표와 사용 예시만!
같은 페이지에? 분가능, query dsl아애 빼고 들어가면, 너무 앞 두 없이 함수들만 나타나는 문제 발생

방법은 짜피 소개 불가능해 보인다(내가 설명할 방법도 없음)























